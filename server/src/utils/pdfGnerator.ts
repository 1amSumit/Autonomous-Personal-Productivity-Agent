import PDFDocument from "pdfkit";
import fs from "fs";
import path from "path";

interface SearchResult {
  title: string;
  url: string;
  content: string;
  score?: number;
}

interface SearchStepData {
  query: string;
  results: SearchResult[];
  stepId: number;
  action: string;
}

export async function generateSearchResultsPDF(
  searchSteps: SearchStepData[],
  goal: string,
  outputPath?: string
): Promise<string> {
  const fileName = `search-results-${Date.now()}.pdf`;
  const filePath = outputPath || path.join(process.cwd(), "tmp", fileName);

  // Ensure tmp directory exists
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: "A4",
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
      });

      const stream = fs.createWriteStream(filePath);
      doc.pipe(stream);

      // Title Page
      doc
        .fontSize(24)
        .font("Helvetica-Bold")
        .text("Research Results Report", { align: "center" });

      doc.moveDown();
      doc
        .fontSize(12)
        .font("Helvetica")
        .text(`Generated: ${new Date().toLocaleString()}`, { align: "center" });

      doc.moveDown();
      doc
        .fontSize(14)
        .font("Helvetica-Bold")
        .text("Goal:", { continued: false });
      doc.fontSize(12).font("Helvetica").text(goal, { align: "left" });

      doc.addPage();

      // Table of Contents
      doc
        .fontSize(18)
        .font("Helvetica-Bold")
        .text("Table of Contents", { underline: true });
      doc.moveDown();

      searchSteps.forEach((step, index) => {
        doc
          .fontSize(12)
          .font("Helvetica")
          .fillColor("blue")
          .text(
            `${index + 1}. ${step.query} (${step.results.length} results)`,
            {
              underline: true,
            }
          )
          .fillColor("black");
        doc.moveDown(0.5);
      });

      // Search Results - Detailed
      searchSteps.forEach((step, stepIndex) => {
        doc.addPage();

        // Section Header
        doc
          .fontSize(18)
          .font("Helvetica-Bold")
          .fillColor("black")
          .text(`Search ${stepIndex + 1}: ${step.query}`);

        doc.moveDown();
        doc
          .fontSize(10)
          .font("Helvetica-Oblique")
          .text(`Step ID: ${step.stepId} | Action: ${step.action}`);
        doc.moveDown();
        doc
          .fontSize(11)
          .font("Helvetica")
          .text(`Total Results: ${step.results.length}`);

        doc.moveDown(1.5);

        // Each Result
        step.results.forEach((result, resultIndex) => {
          // Check if we need a new page
          if (doc.y > 650) {
            doc.addPage();
          }

          // Result Number
          doc
            .fontSize(14)
            .font("Helvetica-Bold")
            .text(`Result ${resultIndex + 1}: ${result.title || "Untitled"}`, {
              continued: false,
            });

          doc.moveDown(0.3);

          // URL (clickable)
          doc
            .fontSize(10)
            .font("Helvetica")
            .fillColor("blue")
            .text(`üîó ${result.url}`, {
              link: result.url,
              underline: true,
            });

          doc.moveDown(0.5);

          // Score (if available)
          if (result.score) {
            doc
              .fontSize(9)
              .font("Helvetica-Oblique")
              .fillColor("gray")
              .text(`Relevance Score: ${(result.score * 100).toFixed(1)}%`);
            doc.moveDown(0.3);
          }

          // Content
          doc
            .fontSize(10)
            .font("Helvetica")
            .fillColor("black")
            .text(result.content || "No content available", {
              align: "justify",
              lineGap: 2,
            });

          doc.moveDown(1);

          // Separator
          doc
            .moveTo(50, doc.y)
            .lineTo(545, doc.y)
            .strokeColor("#cccccc")
            .stroke();

          doc.moveDown(1);
        });
      });

      // Footer on last page
      doc
        .fontSize(9)
        .font("Helvetica-Oblique")
        .fillColor("gray")
        .text(
          `End of Report - Generated by AI Planner System`,
          50,
          doc.page.height - 50,
          { align: "center" }
        );

      doc.end();

      stream.on("finish", () => {
        console.log(`‚úÖ PDF generated successfully: ${filePath}`);
        resolve(filePath);
      });

      stream.on("error", (err) => {
        console.error("‚ùå PDF generation error:", err);
        reject(err);
      });
    } catch (error) {
      reject(error);
    }
  });
}

// Helper function to format search steps from toolResults
export function formatSearchStepsForPDF(
  steps: any[],
  toolResults: Record<number, any>
): SearchStepData[] {
  const searchSteps: SearchStepData[] = [];

  steps
    .filter((s) => s.tool === "search" && toolResults[s.id])
    .forEach((step) => {
      const searchResult = toolResults[step.id];

      // Tavily format: { query, result: { results: [...] } }
      if (searchResult?.result?.results?.length > 0) {
        searchSteps.push({
          query: searchResult.query || step.args.query,
          results: searchResult.result.results,
          stepId: step.id,
          action: step.action,
        });
      }
    });

  return searchSteps;
}
